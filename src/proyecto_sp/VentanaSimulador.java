/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package proyecto_sp;

import javax.swing.SwingUtilities;
/**
 * @author Alessandro Gramcko
 * @author massimo Gramcko
 */
public class VentanaSimulador extends javax.swing.JFrame implements Runnable {

    private static final int QUANTUM = 4;
    private Cola colaListos;
    private Cola colaTerminados;
    private Cola colaBloqueados;
    private int cicloGlobal;
    private PCB procesoEnCpu;
    private Planificador planificador;
    
    
    public VentanaSimulador() {
    initComponents();
    
    // --- AÑADE ESTAS LÍNEAS ---
    this.colaListos = new Cola();
    this.colaTerminados = new Cola();
    this.colaBloqueados = new Cola();
    this.cicloGlobal = 0;
    this.procesoEnCpu = null;
    this.planificador = new Planificador();
    // -------------------------

    // Ahora el resto de tu código funcionará correctamente
    //Proceso p1 = new Proceso("Navegador Web", 10);
    //Proceso p2 = new Proceso("Editor de Texto", 7);
   // Proceso p3 = new Proceso("Música", 12);

    // Creamos su PCB (Process Control Block)
   // PCB pcb1 = new PCB(p1);
    //PCB pcb2 = new PCB(p2);
   // PCB pcb3 = new PCB(p3);

    // Los procesos "llegan" al sistema y se encolan en la lista de listos.
   // pcb1.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb1);
   // pcb2.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb2);
   // pcb3.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb3);
}
    
private void actualizarGUI() {
    // Actualiza el ciclo actual
    lblCicloActual.setText(String.valueOf(cicloGlobal));

    // Actualiza la información del proceso en CPU
    if (procesoEnCpu != null) {
        lblProcesoCPU.setText(procesoEnCpu.getProcesoInfo().getNombre() + " (ID: " + procesoEnCpu.getId() + ")");
        lblProgramCounter.setText(String.valueOf(procesoEnCpu.getProgramCounter()));
    } else {
        lblProcesoCPU.setText("N/A");
        lblProgramCounter.setText("0");
    }

    // Actualiza el JTextArea de la cola de listos
    txtColaListos.setText(colaListos.toString());
    txtTerminados.setText(colaTerminados.toString());
    txtColaBloqueados.setText(colaBloqueados.toString());
    
}

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        txtColaListos = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtColaBloqueados = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtTerminados = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        lblProgramCounter = new javax.swing.JLabel();
        lblProcesoCPU = new javax.swing.JLabel();
        lblCicloActual = new javax.swing.JLabel();
        btnIniciar = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        txtNombreProceso = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        spnInstrucciones = new javax.swing.JSpinner();
        btnCrearProceso = new javax.swing.JButton();
        jLabel9 = new javax.swing.JLabel();
        cmbAlgoritmo = new javax.swing.JComboBox<>();
        chkIoBound = new javax.swing.JCheckBox();
        jLabel10 = new javax.swing.JLabel();
        spnInstruccionIO = new javax.swing.JSpinner();
        jLabel11 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtMetricas = new javax.swing.JTextArea();
        jLabel12 = new javax.swing.JLabel();
        spnPrioridad = new javax.swing.JSpinner();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        txtColaListos.setColumns(20);
        txtColaListos.setRows(5);
        jScrollPane1.setViewportView(txtColaListos);

        txtColaBloqueados.setColumns(20);
        txtColaBloqueados.setRows(5);
        jScrollPane2.setViewportView(txtColaBloqueados);

        txtTerminados.setColumns(20);
        txtTerminados.setRows(5);
        jScrollPane3.setViewportView(txtTerminados);

        jLabel1.setText("   Cola de Listos");

        jLabel2.setText("   Cola de Bloqueados");

        jLabel3.setText("    Procesos Terminados");

        jLabel4.setText("Proceso en CPU:");

        jLabel5.setText("Program Counter:");

        jLabel6.setText("Ciclo Actual:");

        lblProgramCounter.setText("0");

        lblProcesoCPU.setText("N/A");

        lblCicloActual.setText("0");

        btnIniciar.setText("Iniciar Simulación");
        btnIniciar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnIniciarActionPerformed(evt);
            }
        });

        jLabel7.setText("Nombre del Proceso:");

        jLabel8.setText("Número de Instrucciones:");

        btnCrearProceso.setText("Crear Proceso");
        btnCrearProceso.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCrearProcesoActionPerformed(evt);
            }
        });

        jLabel9.setText("Algoritmo:");

        cmbAlgoritmo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "FCFS", "SJF No Apropiativo", "Round Robin", "Prioridad No Apropiativo", "Prioridad Apropiativo" }));

        chkIoBound.setText("Es I/O-Bound");

        jLabel10.setText("Instrucción de E/S:");

        jLabel11.setText("Reporte de Rendimiento:");

        txtMetricas.setColumns(20);
        txtMetricas.setRows(5);
        jScrollPane4.setViewportView(txtMetricas);

        jLabel12.setText("Prioridad:");

        spnPrioridad.setModel(new javax.swing.SpinnerNumberModel(10, null, null, 1));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(64, 64, 64)
                .addComponent(jLabel11, javax.swing.GroupLayout.PREFERRED_SIZE, 141, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(51, 51, 51)
                                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(37, 37, 37))
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 111, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(77, 77, 77))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 195, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(53, 53, 53))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(cmbAlgoritmo, javax.swing.GroupLayout.PREFERRED_SIZE, 124, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(37, 37, 37))))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(chkIoBound)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 149, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spnInstrucciones, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(jScrollPane4)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                        .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtNombreProceso, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(156, 156, 156)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(18, 18, 18)
                                        .addComponent(lblProgramCounter, javax.swing.GroupLayout.PREFERRED_SIZE, 190, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel4)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(lblProcesoCPU, javax.swing.GroupLayout.PREFERRED_SIZE, 205, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addComponent(btnIniciar, javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel6)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(lblCicloActual, javax.swing.GroupLayout.PREFERRED_SIZE, 221, javax.swing.GroupLayout.PREFERRED_SIZE)))))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                        .addComponent(jLabel12, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(spnPrioridad))
                                    .addComponent(jLabel10, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnCrearProceso, javax.swing.GroupLayout.Alignment.LEADING))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spnInstruccionIO, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 99, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(54, 54, 54)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel1)
                    .addComponent(jLabel3)
                    .addComponent(jLabel2))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel11)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 88, Short.MAX_VALUE)
                        .addGap(39, 39, 39)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel7)
                            .addComponent(txtNombreProceso, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel8)
                            .addComponent(spnInstrucciones, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(chkIoBound)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel10)
                            .addComponent(spnInstruccionIO, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(7, 7, 7)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel12)
                            .addComponent(spnPrioridad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(btnCrearProceso)
                        .addGap(156, 156, 156))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(lblProcesoCPU))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel5)
                            .addComponent(lblProgramCounter))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel6)
                            .addComponent(lblCicloActual))
                        .addGap(26, 26, 26)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnIniciar)
                            .addComponent(jLabel9)
                            .addComponent(cmbAlgoritmo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnIniciarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnIniciarActionPerformed
        btnIniciar.setEnabled(false);
        Thread hiloSimulacion = new Thread(this);
        hiloSimulacion.start();
    }//GEN-LAST:event_btnIniciarActionPerformed

    private void btnCrearProcesoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCrearProcesoActionPerformed
        String nombre = txtNombreProceso.getText();
    int instrucciones = (int) spnInstrucciones.getValue();
    boolean esIO = chkIoBound.isSelected();
    int instruccionIO = (int) spnInstruccionIO.getValue();
    int prioridad = (int) spnPrioridad.getValue();

    if (nombre.trim().isEmpty() || instrucciones <= 0 || (esIO && (instruccionIO <= 0 || instruccionIO > instrucciones))) {
        javax.swing.JOptionPane.showMessageDialog(this, "Datos inválidos. La instrucción de E/S debe ser mayor que 0 y menor que el total de instrucciones.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
        return; 
    }

    Proceso nuevoProceso = new Proceso(nombre, instrucciones, esIO, instruccionIO, prioridad);
    PCB nuevoPcb = new PCB(nuevoProceso);
    nuevoPcb.setTiempoDeLlegada(cicloGlobal);
    nuevoPcb.setEstado(PCB.EstadoProceso.LISTO);
    colaListos.encolar(nuevoPcb);

    // Limpiar campos y actualizar GUI
    txtNombreProceso.setText("");
    spnInstrucciones.setValue(0);
    chkIoBound.setSelected(false);
    spnInstruccionIO.setValue(0);
    actualizarGUI();
    }//GEN-LAST:event_btnCrearProcesoActionPerformed

    /**
     * @param args the command line arguments
     */


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCrearProceso;
    private javax.swing.JButton btnIniciar;
    private javax.swing.JCheckBox chkIoBound;
    private javax.swing.JComboBox<String> cmbAlgoritmo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JLabel lblCicloActual;
    private javax.swing.JLabel lblProcesoCPU;
    private javax.swing.JLabel lblProgramCounter;
    private javax.swing.JSpinner spnInstruccionIO;
    private javax.swing.JSpinner spnInstrucciones;
    private javax.swing.JSpinner spnPrioridad;
    private javax.swing.JTextArea txtColaBloqueados;
    private javax.swing.JTextArea txtColaListos;
    private javax.swing.JTextArea txtMetricas;
    private javax.swing.JTextField txtNombreProceso;
    private javax.swing.JTextArea txtTerminados;
    // End of variables declaration//GEN-END:variables

@Override
public void run() {
    while (procesoEnCpu != null || !colaListos.estaVacia() || !colaBloqueados.estaVacia()) {

        gestionarColaBloqueados();
        String algoritmo = (String) cmbAlgoritmo.getSelectedItem();

        // <-- INICIO: NUEVO BLOQUE DE APROPIACIÓN POR PRIORIDAD -->
        // Comprueba si un proceso en la cola de listos tiene mayor prioridad que el que se está ejecutando.
        if (algoritmo.equals("Prioridad Apropiativo") && procesoEnCpu != null && !colaListos.estaVacia()) {
            PCB masPrioritarioEnCola = planificador.verProcesoMasPrioritario(colaListos);
            if (masPrioritarioEnCola.getProcesoInfo().getPrioridad() < procesoEnCpu.getProcesoInfo().getPrioridad()) {
                // Si es así, se interrumpe al proceso actual y se libera la CPU.
                procesoEnCpu.setEstado(PCB.EstadoProceso.LISTO);
                colaListos.encolar(procesoEnCpu);
                procesoEnCpu = null;
            }
        }
        // <-- FIN: NUEVO BLOQUE DE APROPIACIÓN -->

        if (procesoEnCpu == null) {
            procesoEnCpu = planificador.seleccionarProceso(colaListos, algoritmo);
            if (procesoEnCpu != null) {
                procesoEnCpu.setEstado(PCB.EstadoProceso.EJECUCION);
                // <-- CORREGIDO: El quantum solo se asigna para Round Robin -->
                if (algoritmo.equals("Round Robin")) {
                    procesoEnCpu.setQuantumRestante(QUANTUM); 
                }
            }
        }

        cicloGlobal++;

        if (procesoEnCpu != null) {
            
            // <-- CORREGIDO: El quantum solo se descuenta para Round Robin -->
            if (algoritmo.equals("Round Robin")) {
                procesoEnCpu.setQuantumRestante(procesoEnCpu.getQuantumRestante() - 1);
            }
            
            // El resto de la lógica de ejecución no cambia
            if (procesoEnCpu.getProcesoInfo().esIoBound() && 
                procesoEnCpu.getProgramCounter() == procesoEnCpu.getProcesoInfo().getInstruccionBloqueo()) {
                
                procesoEnCpu.setEstado(PCB.EstadoProceso.BLOQUEADO);
                procesoEnCpu.setTiempoRestanteBloqueo(10);
                colaBloqueados.encolar(procesoEnCpu);
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
                procesoEnCpu = null;

            } else if (procesoEnCpu.getProgramCounter() >= procesoEnCpu.getProcesoInfo().getNumeroInstrucciones()) {
                procesoEnCpu.setEstado(PCB.EstadoProceso.TERMINADO);
                procesoEnCpu.setTiempoDeFinalizacion(cicloGlobal);
                colaTerminados.encolar(procesoEnCpu);
                procesoEnCpu = null;

            } else if (algoritmo.equals("Round Robin") && procesoEnCpu.getQuantumRestante() <= 0) {
                procesoEnCpu.setEstado(PCB.EstadoProceso.LISTO);
                colaListos.encolar(procesoEnCpu);
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
                procesoEnCpu = null;

            } else {
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
            }
        }

        SwingUtilities.invokeLater(this::actualizarGUI);
        try { 
            Thread.sleep(500); 
        } catch (InterruptedException e) { 
            Thread.currentThread().interrupt(); 
        }
    }
    
    System.out.println("--- Simulación Finalizada ---");
    calcularYMostrarMetricas();
    SwingUtilities.invokeLater(() -> {
        btnIniciar.setEnabled(true);
        cmbAlgoritmo.setEnabled(true);
    });
} // <--- FIN DEL MÉTODO run()




private void gestionarColaBloqueados() {
    if (colaBloqueados.estaVacia()) {
        return; // No hay nada que hacer si la cola está vacía
    }

    Nodo actual = colaBloqueados.getFrente();
    Nodo anterior = null;
    while (actual != null) {
        PCB pcb = actual.getPcb();
        // Restamos un ciclo al tiempo de bloqueo
        pcb.setTiempoRestanteBloqueo(pcb.getTiempoRestanteBloqueo() - 1);
        
        Nodo siguiente = actual.getSiguiente(); // Guardamos el siguiente nodo antes de hacer cambios

        if (pcb.getTiempoRestanteBloqueo() <= 0) {
            // ¡Tiempo de bloqueo terminado! El proceso vuelve a la cola de listos.
            pcb.setEstado(PCB.EstadoProceso.LISTO);
            colaListos.encolar(pcb);
            
            // Lo quitamos de la cola de bloqueados
            if (anterior == null) {
                // Era el primer elemento de la cola
                colaBloqueados.setFrente(siguiente);
                if (colaBloqueados.getFrente() == null) { // La cola quedó vacía
                    colaBloqueados.setFin(null);
                }
            } else {
                // Estaba en medio o al final
                anterior.setSiguiente(siguiente);
                if (siguiente == null) { // Era el último
                    colaBloqueados.setFin(anterior);
                }
            }
        } else {
            // Si todavía no ha terminado de esperar, 'anterior' avanza.
            anterior = actual;
        }
        // Avanzamos al siguiente nodo de la lista original.
        actual = siguiente;
    }
   }


private void calcularYMostrarMetricas() {
    if (colaTerminados.estaVacia()) return;

    StringBuilder reporte = new StringBuilder();
    reporte.append("--- REPORTE DE RENDIMIENTO ---\n");

    int totalRetorno = 0;
    int totalEspera = 0;
    int numProcesos = 0;

    Nodo actual = colaTerminados.getFrente();
    while(actual != null) {
        PCB pcb = actual.getPcb();

        // Calcular métricas para este PCB
        int retorno = pcb.getTiempoDeFinalizacion() - pcb.getTiempoDeLlegada();
        pcb.setTiempoDeRetorno(retorno);

        int espera = retorno - pcb.getProcesoInfo().getNumeroInstrucciones();
        pcb.setTiempoDeEspera(espera);

        totalRetorno += retorno;
        totalEspera += espera;
        numProcesos++;

        reporte.append("ID: ").append(pcb.getId())
               .append(" | T. Retorno: ").append(retorno)
               .append(" | T. Espera: ").append(espera).append("\n");

        actual = actual.getSiguiente();
    }

    double promedioRetorno = (double) totalRetorno / numProcesos;
    double promedioEspera = (double) totalEspera / numProcesos;

    reporte.append("---------------------------------\n");
    reporte.append(String.format("Promedio de T. de Retorno: %.2f\n", promedioRetorno));
    reporte.append(String.format("Promedio de T. de Espera: %.2f\n", promedioEspera));

    txtMetricas.setText(reporte.toString());
    }
}

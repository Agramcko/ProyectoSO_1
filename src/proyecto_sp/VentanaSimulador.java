/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package proyecto_sp;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import java.awt.BorderLayout;
import javax.swing.SwingUtilities;
import javax.swing.JOptionPane;
/**
 * @author Alessandro Gramcko
 * @author massimo Gramcko
 */
public class VentanaSimulador extends javax.swing.JFrame implements Runnable {

    private static final int QUANTUM = 4;
    private static final int MEMORIA_TOTAL_MB = 2048; // Simula 2GB de RAM
    private Cola colaListos;
    private Cola colaTerminados;
    private Cola colaBloqueados;
    private Cola colaListosSuspendidos;
    private int cicloGlobal;
    private int ciclosOcupado;
    private int memoriaEnUso;
    private PCB procesoEnCpu;
    private Planificador planificador;
    private XYSeries seriesUtilizacionCPU;
    private JFreeChart grafico;
    
    
    public VentanaSimulador() {
    initComponents();
    
    // --- AÑADE ESTAS LÍNEAS ---
    this.colaListos = new Cola();
    this.colaTerminados = new Cola();
    this.colaBloqueados = new Cola();
    this.colaListosSuspendidos = new Cola();
    this.cicloGlobal = 0;
    this.ciclosOcupado = 0;
    this.procesoEnCpu = null;
    this.planificador = new Planificador();
    inicializarGrafico();
    // -------------------------

    // Ahora el resto de tu código funcionará correctamente
    //Proceso p1 = new Proceso("Navegador Web", 10);
    //Proceso p2 = new Proceso("Editor de Texto", 7);
   // Proceso p3 = new Proceso("Música", 12);

    // Creamos su PCB (Process Control Block)
   // PCB pcb1 = new PCB(p1);
    //PCB pcb2 = new PCB(p2);
   // PCB pcb3 = new PCB(p3);

    // Los procesos "llegan" al sistema y se encolan en la lista de listos.
   // pcb1.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb1);
   // pcb2.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb2);
   // pcb3.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb3);
}
    
private void actualizarGUI() {
    // Actualiza el ciclo actual
    lblCicloActual.setText(String.valueOf(cicloGlobal));

    // Actualiza la información del proceso en CPU
    if (procesoEnCpu != null) {
        lblProcesoCPU.setText(procesoEnCpu.getProcesoInfo().getNombre() + " (ID: " + procesoEnCpu.getId() + ")");
        lblProgramCounter.setText(String.valueOf(procesoEnCpu.getProgramCounter()));
    } else {
        lblProcesoCPU.setText("N/A");
        lblProgramCounter.setText("0");
    }

    // Actualiza el JTextArea de la cola de listos
    txtColaListos.setText(colaListos.toString());
    txtTerminados.setText(colaTerminados.toString());
    txtColaBloqueados.setText(colaBloqueados.toString());
    txtColaListosSuspendidos.setText(colaListosSuspendidos.toString());
    
}

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        txtColaListos = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtColaBloqueados = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtTerminados = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        lblProgramCounter = new javax.swing.JLabel();
        lblProcesoCPU = new javax.swing.JLabel();
        lblCicloActual = new javax.swing.JLabel();
        btnIniciar = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        txtNombreProceso = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        spnInstrucciones = new javax.swing.JSpinner();
        btnCrearProceso = new javax.swing.JButton();
        jLabel9 = new javax.swing.JLabel();
        cmbAlgoritmo = new javax.swing.JComboBox<>();
        chkIoBound = new javax.swing.JCheckBox();
        jLabel10 = new javax.swing.JLabel();
        spnInstruccionIO = new javax.swing.JSpinner();
        jLabel11 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtMetricas = new javax.swing.JTextArea();
        jLabel12 = new javax.swing.JLabel();
        spnPrioridad = new javax.swing.JSpinner();
        panelGrafico = new javax.swing.JPanel();
        jLabel13 = new javax.swing.JLabel();
        spnTamaño = new javax.swing.JSpinner();
        jLabel14 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        txtColaListosSuspendidos = new javax.swing.JTextArea();
        jLabel15 = new javax.swing.JLabel();
        spnVelocidad = new javax.swing.JSpinner();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        txtColaListos.setColumns(20);
        txtColaListos.setRows(5);
        jScrollPane1.setViewportView(txtColaListos);

        txtColaBloqueados.setColumns(20);
        txtColaBloqueados.setRows(5);
        jScrollPane2.setViewportView(txtColaBloqueados);

        txtTerminados.setColumns(20);
        txtTerminados.setRows(5);
        jScrollPane3.setViewportView(txtTerminados);

        jLabel1.setText("   Cola de Listos");

        jLabel2.setText("   Cola de Bloqueados");

        jLabel3.setText("    Procesos Terminados");

        jLabel4.setText("Proceso en CPU:");

        jLabel5.setText("Program Counter:");

        jLabel6.setText("Ciclo Actual:");

        lblProgramCounter.setText("0");

        lblProcesoCPU.setText("N/A");

        lblCicloActual.setText("0");

        btnIniciar.setText("Iniciar Simulación");
        btnIniciar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnIniciarActionPerformed(evt);
            }
        });

        jLabel7.setText("Nombre del Proceso:");

        jLabel8.setText("Número de Instrucciones:");

        btnCrearProceso.setText("Crear Proceso");
        btnCrearProceso.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCrearProcesoActionPerformed(evt);
            }
        });

        jLabel9.setText("Algoritmo:");

        cmbAlgoritmo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "FCFS", "SJF No Apropiativo", "Round Robin", "Prioridad No Apropiativo", "Prioridad Apropiativo" }));

        chkIoBound.setText("Es I/O-Bound");

        jLabel10.setText("Instrucción de E/S:");

        jLabel11.setText("Reporte de Rendimiento:");

        txtMetricas.setColumns(20);
        txtMetricas.setRows(5);
        jScrollPane4.setViewportView(txtMetricas);

        jLabel12.setText("Prioridad:");

        spnPrioridad.setModel(new javax.swing.SpinnerNumberModel(10, null, null, 1));

        javax.swing.GroupLayout panelGraficoLayout = new javax.swing.GroupLayout(panelGrafico);
        panelGrafico.setLayout(panelGraficoLayout);
        panelGraficoLayout.setHorizontalGroup(
            panelGraficoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 457, Short.MAX_VALUE)
        );
        panelGraficoLayout.setVerticalGroup(
            panelGraficoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 297, Short.MAX_VALUE)
        );

        jLabel13.setText("Tamaño (MB):");

        spnTamaño.setModel(new javax.swing.SpinnerNumberModel(100, null, null, 1));

        jLabel14.setText("Cola de Listos-Suspendidos");

        txtColaListosSuspendidos.setColumns(20);
        txtColaListosSuspendidos.setRows(5);
        jScrollPane5.setViewportView(txtColaListosSuspendidos);

        jLabel15.setText("Velocidad (ms):");

        spnVelocidad.setModel(new javax.swing.SpinnerNumberModel(500, null, null, 1));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 207, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(55, 55, 55)
                                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 207, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 71, Short.MAX_VALUE)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(34, 34, 34))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(51, 51, 51)
                                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(134, 134, 134)
                                .addComponent(jLabel14)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(93, 93, 93)))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(24, 24, 24))
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 195, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addComponent(jScrollPane4)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                        .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(txtNombreProceso, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(156, 156, 156)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addGap(18, 18, 18)
                                            .addComponent(lblProgramCounter, javax.swing.GroupLayout.PREFERRED_SIZE, 190, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel4)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                            .addComponent(lblProcesoCPU, javax.swing.GroupLayout.PREFERRED_SIZE, 205, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                            .addComponent(jLabel6)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(lblCicloActual, javax.swing.GroupLayout.PREFERRED_SIZE, 221, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(cmbAlgoritmo, javax.swing.GroupLayout.PREFERRED_SIZE, 124, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(btnIniciar)
                                        .addGap(51, 51, 51)
                                        .addComponent(jLabel15, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(spnVelocidad, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE))))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(chkIoBound)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 149, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(spnInstrucciones, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                                .addComponent(jLabel12, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                .addComponent(spnPrioridad))
                                            .addComponent(jLabel10, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(btnCrearProceso, javax.swing.GroupLayout.Alignment.LEADING))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(spnInstruccionIO, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel13, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(spnTamaño, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(132, 132, 132)
                                .addComponent(panelGrafico, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 0, Short.MAX_VALUE))))
            .addGroup(layout.createSequentialGroup()
                .addGap(64, 64, 64)
                .addComponent(jLabel11, javax.swing.GroupLayout.PREFERRED_SIZE, 157, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(54, 54, 54)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel1)
                        .addComponent(jLabel14, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel2)))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel11)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 174, Short.MAX_VALUE)
                        .addGap(39, 39, 39)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel7)
                            .addComponent(txtNombreProceso, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(lblProcesoCPU))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel5)
                            .addComponent(lblProgramCounter))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel6)
                            .addComponent(lblCicloActual))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel9)
                            .addComponent(cmbAlgoritmo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(20, 20, 20)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnIniciar)
                            .addComponent(jLabel15)
                            .addComponent(spnVelocidad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel8)
                            .addComponent(spnInstrucciones, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(chkIoBound)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel10)
                            .addComponent(spnInstruccionIO, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(7, 7, 7)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel12)
                            .addComponent(spnPrioridad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel13)
                            .addComponent(spnTamaño, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(13, 13, 13)
                        .addComponent(btnCrearProceso))
                    .addComponent(panelGrafico, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnIniciarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnIniciarActionPerformed
        btnIniciar.setEnabled(false);
        Thread hiloSimulacion = new Thread(this);
        hiloSimulacion.start();
    }//GEN-LAST:event_btnIniciarActionPerformed

    private void btnCrearProcesoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCrearProcesoActionPerformed
       String nombre = txtNombreProceso.getText();
    int instrucciones = (int) spnInstrucciones.getValue();
    boolean esIO = chkIoBound.isSelected();
    int instruccionIO = (int) spnInstruccionIO.getValue();
    int prioridad = (int) spnPrioridad.getValue();
    int tamaño = (int) spnTamaño.getValue(); // Leemos el nuevo campo

    if (nombre.isEmpty() || instrucciones <= 0 || tamaño <= 0) {
        JOptionPane.showMessageDialog(this, "Por favor, complete los campos válidamente.", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }

    Proceso nuevoProceso = new Proceso(nombre, instrucciones, esIO, instruccionIO, prioridad, tamaño);
    PCB nuevoPcb = new PCB(nuevoProceso);
    nuevoPcb.setTiempoDeLlegada(cicloGlobal);

    // --- LÓGICA DE GESTIÓN DE MEMORIA ---
    if ((memoriaEnUso + tamaño) <= MEMORIA_TOTAL_MB) {
        // Hay espacio en la memoria
        memoriaEnUso += tamaño;
        nuevoPcb.setEstado(PCB.EstadoProceso.LISTO);
        colaListos.encolar(nuevoPcb);
        System.out.println("Proceso " + nuevoPcb.getId() + " admitido en memoria.");
    } else {
        // No hay espacio, va a la cola de suspendidos
        nuevoPcb.setEstado(PCB.EstadoProceso.LISTO_SUSPENDIDO); // (Necesitaremos añadir este estado)
        colaListosSuspendidos.encolar(nuevoPcb);
        System.out.println("Proceso " + nuevoPcb.getId() + " enviado a suspendidos por falta de memoria.");
    }
    
    limpiarCamposCreacion();
    actualizarGUI();
    }//GEN-LAST:event_btnCrearProcesoActionPerformed

    /**
     * @param args the command line arguments
     */


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCrearProceso;
    private javax.swing.JButton btnIniciar;
    private javax.swing.JCheckBox chkIoBound;
    private javax.swing.JComboBox<String> cmbAlgoritmo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JLabel lblCicloActual;
    private javax.swing.JLabel lblProcesoCPU;
    private javax.swing.JLabel lblProgramCounter;
    private javax.swing.JPanel panelGrafico;
    private javax.swing.JSpinner spnInstruccionIO;
    private javax.swing.JSpinner spnInstrucciones;
    private javax.swing.JSpinner spnPrioridad;
    private javax.swing.JSpinner spnTamaño;
    private javax.swing.JSpinner spnVelocidad;
    private javax.swing.JTextArea txtColaBloqueados;
    private javax.swing.JTextArea txtColaListos;
    private javax.swing.JTextArea txtColaListosSuspendidos;
    private javax.swing.JTextArea txtMetricas;
    private javax.swing.JTextField txtNombreProceso;
    private javax.swing.JTextArea txtTerminados;
    // End of variables declaration//GEN-END:variables

@Override
public void run() {
    while (procesoEnCpu != null || !colaListos.estaVacia() || !colaBloqueados.estaVacia() || !colaListosSuspendidos.estaVacia()) {

        gestionarColaBloqueados();
        gestionarColaSuspendidos();
        String algoritmo = (String) cmbAlgoritmo.getSelectedItem();

        // Bloque de apropiación por prioridad (no cambia)
        if (algoritmo.equals("Prioridad Apropiativo") && procesoEnCpu != null && !colaListos.estaVacia()) {
            PCB masPrioritarioEnCola = planificador.verProcesoMasPrioritario(colaListos);
            if (masPrioritarioEnCola.getProcesoInfo().getPrioridad() < procesoEnCpu.getProcesoInfo().getPrioridad()) {
                procesoEnCpu.setEstado(PCB.EstadoProceso.LISTO);
                colaListos.encolar(procesoEnCpu);
                procesoEnCpu = null;
            }
        }

        // Lógica de selección de proceso (no cambia)
        if (procesoEnCpu == null) {
            procesoEnCpu = planificador.seleccionarProceso(colaListos, algoritmo);
            if (procesoEnCpu != null) {
                procesoEnCpu.setEstado(PCB.EstadoProceso.EJECUCION);
                if (algoritmo.equals("Round Robin")) {
                    procesoEnCpu.setQuantumRestante(QUANTUM); 
                }
            }
        }

        cicloGlobal++;

        if (procesoEnCpu != null) {
            ciclosOcupado++; 
            if (algoritmo.equals("Round Robin")) {
                procesoEnCpu.setQuantumRestante(procesoEnCpu.getQuantumRestante() - 1);
            }
            
            if (procesoEnCpu.getProcesoInfo().esIoBound() && 
                procesoEnCpu.getProgramCounter() == procesoEnCpu.getProcesoInfo().getInstruccionBloqueo()) {
                
                procesoEnCpu.setEstado(PCB.EstadoProceso.BLOQUEADO);
                procesoEnCpu.setTiempoRestanteBloqueo(10);
                colaBloqueados.encolar(procesoEnCpu);
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
                procesoEnCpu = null;

            } else if (procesoEnCpu.getProgramCounter() >= procesoEnCpu.getProcesoInfo().getNumeroInstrucciones()) {
                procesoEnCpu.setEstado(PCB.EstadoProceso.TERMINADO);
                procesoEnCpu.setTiempoDeFinalizacion(cicloGlobal);
                memoriaEnUso -= procesoEnCpu.getProcesoInfo().getTamañoEnMemoria(); 
                System.out.println("Memoria liberada: " + procesoEnCpu.getProcesoInfo().getTamañoEnMemoria() + " MB. Uso actual: " + memoriaEnUso + " MB.");
                colaTerminados.encolar(procesoEnCpu);
                procesoEnCpu = null;
                
            } else if (algoritmo.equals("Round Robin") && procesoEnCpu.getQuantumRestante() <= 0) {
                procesoEnCpu.setEstado(PCB.EstadoProceso.LISTO);
                colaListos.encolar(procesoEnCpu);
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
                procesoEnCpu = null;

            } else {
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
            }
        }

        SwingUtilities.invokeLater(() -> {
            actualizarGUI();
            actualizarGrafico();
        });

        // --- INICIO DE LA MODIFICACIÓN ---
        // Ahora la pausa lee el valor del JSpinner
        try { 
            int velocidad = (int) spnVelocidad.getValue();
            Thread.sleep(velocidad); 
        } catch (InterruptedException e) { 
            Thread.currentThread().interrupt(); 
        }
        // --- FIN DE LA MODIFICACIÓN ---
    }
    
    // El código de finalización no cambia
    System.out.println("--- Simulación Finalizada ---");
    calcularYMostrarMetricas();
    SwingUtilities.invokeLater(() -> {
        btnIniciar.setEnabled(true);
        cmbAlgoritmo.setEnabled(true);
    });
} // <--- FIN DEL MÉTODO run()




private void gestionarColaBloqueados() {
    if (colaBloqueados.estaVacia()) {
        return; // No hay nada que hacer si la cola está vacía
    }

    Nodo actual = colaBloqueados.getFrente();
    Nodo anterior = null;
    while (actual != null) {
        PCB pcb = actual.getPcb();
        // Restamos un ciclo al tiempo de bloqueo
        pcb.setTiempoRestanteBloqueo(pcb.getTiempoRestanteBloqueo() - 1);
        
        Nodo siguiente = actual.getSiguiente(); // Guardamos el siguiente nodo antes de hacer cambios

        if (pcb.getTiempoRestanteBloqueo() <= 0) {
            // ¡Tiempo de bloqueo terminado! El proceso vuelve a la cola de listos.
            pcb.setEstado(PCB.EstadoProceso.LISTO);
            colaListos.encolar(pcb);
            
            // Lo quitamos de la cola de bloqueados
            if (anterior == null) {
                // Era el primer elemento de la cola
                colaBloqueados.setFrente(siguiente);
                if (colaBloqueados.getFrente() == null) { // La cola quedó vacía
                    colaBloqueados.setFin(null);
                }
            } else {
                // Estaba en medio o al final
                anterior.setSiguiente(siguiente);
                if (siguiente == null) { // Era el último
                    colaBloqueados.setFin(anterior);
                }
            }
        } else {
            // Si todavía no ha terminado de esperar, 'anterior' avanza.
            anterior = actual;
        }
        // Avanzamos al siguiente nodo de la lista original.
        actual = siguiente;
    }
   }


private void calcularYMostrarMetricas() {
    if (colaTerminados.estaVacia()) return;

    StringBuilder reporte = new StringBuilder();
    reporte.append("--- REPORTE DE RENDIMIENTO ---\n");
    
    int totalRetorno = 0;
    int totalEspera = 0;
    int numProcesos = 0;

    Nodo actual = colaTerminados.getFrente();
    while(actual != null) {
        // ... (tu código existente para calcular retorno y espera) ...
        // Esto no cambia
        PCB pcb = actual.getPcb();
        int retorno = pcb.getTiempoDeFinalizacion() - pcb.getTiempoDeLlegada();
        pcb.setTiempoDeRetorno(retorno);
        int espera = retorno - pcb.getProcesoInfo().getNumeroInstrucciones();
        pcb.setTiempoDeEspera(espera);
        totalRetorno += retorno;
        totalEspera += espera;
        numProcesos++;
        reporte.append("ID: ").append(pcb.getId())
               .append(" | T. Retorno: ").append(retorno)
               .append(" | T. Espera: ").append(espera).append("\n");
        actual = actual.getSiguiente();
    }

    // --- INICIO DE LAS NUEVAS MÉTRICAS ---
    double promedioRetorno = (double) totalRetorno / numProcesos;
    double promedioEspera = (double) totalEspera / numProcesos;
    
    // Throughput: Procesos completados por unidad de tiempo
    double throughput = (double) numProcesos / cicloGlobal;
    
    // Utilización de CPU: Porcentaje de tiempo que la CPU estuvo ocupada
    double utilizacionCPU = ((double) ciclosOcupado / cicloGlobal) * 100.0;

    reporte.append("---------------------------------\n");
    reporte.append(String.format("Promedio de T. de Retorno: %.2f\n", promedioRetorno));
    reporte.append(String.format("Promedio de T. de Espera: %.2f\n", promedioEspera));
    reporte.append(String.format("Throughput: %.3f procesos/ciclo\n", throughput));
    reporte.append(String.format("Utilización de CPU: %.2f%%\n", utilizacionCPU));
    // --- FIN DE LAS NUEVAS MÉTRICAS ---

    txtMetricas.setText(reporte.toString());
    }

private void inicializarGrafico() {
    // 1. Crear el conjunto de datos
    this.seriesUtilizacionCPU = new XYSeries("Utilización de CPU");
    XYSeriesCollection dataset = new XYSeriesCollection(this.seriesUtilizacionCPU);

    // 2. Crear el gráfico
    this.grafico = ChartFactory.createXYLineChart(
        "Rendimiento del Sistema", // Título del gráfico
        "Ciclo",                   // Etiqueta del eje X
        "Utilización de CPU (%)",  // Etiqueta del eje Y
        dataset                    // Los datos
    );

    // 3. Crear el panel del gráfico y añadirlo a nuestro JPanel
    ChartPanel chartPanel = new ChartPanel(grafico);
    panelGrafico.setLayout(new java.awt.BorderLayout());
    panelGrafico.add(chartPanel, BorderLayout.CENTER);
    panelGrafico.validate();
    }

private void actualizarGrafico() {
    if (cicloGlobal > 0) {
        // Calculamos la utilización de CPU actual
        double utilizacionActual = ((double) ciclosOcupado / cicloGlobal) * 100.0;
        
        // Añadimos el nuevo punto de datos (ciclo, utilización) a la serie
        this.seriesUtilizacionCPU.add(cicloGlobal, utilizacionActual);
    }
   }

private void limpiarCamposCreacion() {
    // Resetea los campos del formulario a sus valores por defecto
    txtNombreProceso.setText("");
    spnInstrucciones.setValue(0);
    chkIoBound.setSelected(false);
    spnInstruccionIO.setValue(0);
    spnPrioridad.setValue(10);
    spnTamaño.setValue(100);
    
    }

private void gestionarColaSuspendidos() {
    // Revisa si hay procesos esperando y si la cola no está vacía
    if (!colaListosSuspendidos.estaVacia()) {
        // "Espiamos" al primer proceso en la cola sin sacarlo todavía
        PCB procesoInteresado = colaListosSuspendidos.verFrente();
        
        // Verificamos si hay suficiente memoria para él
        if ((memoriaEnUso + procesoInteresado.getProcesoInfo().getTamañoEnMemoria()) <= MEMORIA_TOTAL_MB) {
            
            // ¡Sí cabe! Lo sacamos de suspendidos
            PCB procesoAdmitido = colaListosSuspendidos.desencolar();
            
            // Actualizamos su estado y la memoria en uso
            procesoAdmitido.setEstado(PCB.EstadoProceso.LISTO);
            memoriaEnUso += procesoAdmitido.getProcesoInfo().getTamañoEnMemoria();
            
            // Lo enviamos a la cola de listos para que pueda competir por la CPU
            colaListos.encolar(procesoAdmitido);
            
            System.out.println("Proceso " + procesoAdmitido.getId() + " movido de suspendido a listo. Uso de memoria: " + memoriaEnUso + " MB.");
        }
    }
    }
}

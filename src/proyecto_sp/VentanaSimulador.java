/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package proyecto_sp;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import java.awt.BorderLayout;
import javax.swing.SwingUtilities;
import javax.swing.JOptionPane;
import org.json.JSONObject;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
/**
 * @author Alessandro Gramcko
 * @author massimo Gramcko
 */
public class VentanaSimulador extends javax.swing.JFrame implements Runnable {

    private static final int QUANTUM = 4;
    private static final int MEMORIA_TOTAL_MB = 2048; // Simula 2GB de RAM
    private Cola colaListos;
    private Cola colaTerminados;
    private Cola colaBloqueados;
    private Cola colaListosSuspendidos;
    private Cola colaBloqueadosSuspendidos;
    private int cicloGlobal;
    private int ciclosOcupado;
    private int memoriaEnUso;
    private PCB procesoEnCpu;
    private Planificador planificador;
    private XYSeries seriesUtilizacionCPU;
    private JFreeChart grafico;
    
    
    
    public VentanaSimulador() {
    initComponents();
    
    // --- AÑADE ESTAS LÍNEAS ---
    this.colaListos = new Cola();
    this.colaTerminados = new Cola();
    this.colaBloqueados = new Cola();
    this.colaListosSuspendidos = new Cola();
    this.colaBloqueadosSuspendidos = new Cola();
    this.cicloGlobal = 0;
    this.ciclosOcupado = 0;
    this.procesoEnCpu = null;
    this.planificador = new Planificador();
    inicializarGrafico();
    cargarConfiguracion();
   
    addWindowListener(new java.awt.event.WindowAdapter() {
        @Override
        public void windowClosing(java.awt.event.WindowEvent windowEvent) {
            guardarConfiguracion();
        }
    });
    // -------------------------

    // Ahora el resto de tu código funcionará correctamente
    //Proceso p1 = new Proceso("Navegador Web", 10);
    //Proceso p2 = new Proceso("Editor de Texto", 7);
   // Proceso p3 = new Proceso("Música", 12);

    // Creamos su PCB (Process Control Block)
   // PCB pcb1 = new PCB(p1);
    //PCB pcb2 = new PCB(p2);
   // PCB pcb3 = new PCB(p3);

    // Los procesos "llegan" al sistema y se encolan en la lista de listos.
   // pcb1.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb1);
   // pcb2.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb2);
   // pcb3.setEstado(PCB.EstadoProceso.LISTO);
   // colaListos.encolar(pcb3);
}
    
private void actualizarGUI() {
    // Actualiza el ciclo actual
    lblCicloActual.setText(String.valueOf(cicloGlobal));

    // Actualiza la información del proceso en CPU
    if (procesoEnCpu != null) {
        lblProcesoCPU.setText(procesoEnCpu.getProcesoInfo().getNombre() + " (ID: " + procesoEnCpu.getId() + ")");
        lblProgramCounter.setText(String.valueOf(procesoEnCpu.getProgramCounter()));
        lblMAR.setText(String.valueOf(procesoEnCpu.getProgramCounter())); // <-- LÍNEA AÑADIDA
    } else {
        lblProcesoCPU.setText("N/A");
        lblProgramCounter.setText("0");
        lblMAR.setText("-"); // <-- LÍNEA AÑADIDA
    }

    // Actualiza el JTextArea de las colas (esto no cambia)
    txtColaListos.setText(colaListos.toString());
    txtTerminados.setText(colaTerminados.toString());
    txtColaBloqueados.setText(colaBloqueados.toString());
    txtColaListosSuspendidos.setText(colaListosSuspendidos.toString());
    txtColaBloqueadosSuspendidos.setText(colaBloqueadosSuspendidos.toString());
}

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        txtColaListos = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        txtColaBloqueados = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        txtTerminados = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        lblProgramCounter = new javax.swing.JLabel();
        lblProcesoCPU = new javax.swing.JLabel();
        lblCicloActual = new javax.swing.JLabel();
        btnIniciar = new javax.swing.JButton();
        jLabel7 = new javax.swing.JLabel();
        txtNombreProceso = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        spnInstrucciones = new javax.swing.JSpinner();
        btnCrearProceso = new javax.swing.JButton();
        jLabel9 = new javax.swing.JLabel();
        cmbAlgoritmo = new javax.swing.JComboBox<>();
        chkIoBound = new javax.swing.JCheckBox();
        jLabel10 = new javax.swing.JLabel();
        spnInstruccionIO = new javax.swing.JSpinner();
        jLabel11 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtMetricas = new javax.swing.JTextArea();
        jLabel12 = new javax.swing.JLabel();
        spnPrioridad = new javax.swing.JSpinner();
        panelGrafico = new javax.swing.JPanel();
        jLabel13 = new javax.swing.JLabel();
        spnTamaño = new javax.swing.JSpinner();
        jLabel14 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        txtColaListosSuspendidos = new javax.swing.JTextArea();
        jLabel15 = new javax.swing.JLabel();
        spnVelocidad = new javax.swing.JSpinner();
        jLabel16 = new javax.swing.JLabel();
        jScrollPane6 = new javax.swing.JScrollPane();
        txtColaBloqueadosSuspendidos = new javax.swing.JTextArea();
        lblMAR = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        txtColaListos.setColumns(20);
        txtColaListos.setRows(5);
        jScrollPane1.setViewportView(txtColaListos);

        txtColaBloqueados.setColumns(20);
        txtColaBloqueados.setRows(5);
        jScrollPane2.setViewportView(txtColaBloqueados);

        txtTerminados.setColumns(20);
        txtTerminados.setRows(5);
        jScrollPane3.setViewportView(txtTerminados);

        jLabel1.setText("   Cola de Listos");

        jLabel2.setText("   Cola de Bloqueados");

        jLabel3.setText("    Procesos Terminados");

        jLabel4.setText("Proceso en CPU:");

        jLabel5.setText("Program Counter:");

        jLabel6.setText("Ciclo Actual:");

        lblProgramCounter.setText("0");

        lblProcesoCPU.setText("N/A");

        lblCicloActual.setText("0");

        btnIniciar.setText("Iniciar Simulación");
        btnIniciar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnIniciarActionPerformed(evt);
            }
        });

        jLabel7.setText("Nombre del Proceso:");

        jLabel8.setText("Número de Instrucciones:");

        btnCrearProceso.setText("Crear Proceso");
        btnCrearProceso.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCrearProcesoActionPerformed(evt);
            }
        });

        jLabel9.setText("Algoritmo:");

        cmbAlgoritmo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "FCFS", "SJF No Apropiativo", "Round Robin", "Prioridad No Apropiativo", "Prioridad Apropiativo", "SRT (Shortest Remaining Time)" }));

        chkIoBound.setText("Es I/O-Bound");

        jLabel10.setText("Instrucción de E/S:");

        jLabel11.setText("Reporte de Rendimiento:");

        txtMetricas.setColumns(20);
        txtMetricas.setRows(5);
        jScrollPane4.setViewportView(txtMetricas);

        jLabel12.setText("Prioridad:");

        spnPrioridad.setModel(new javax.swing.SpinnerNumberModel(10, null, null, 1));

        javax.swing.GroupLayout panelGraficoLayout = new javax.swing.GroupLayout(panelGrafico);
        panelGrafico.setLayout(panelGraficoLayout);
        panelGraficoLayout.setHorizontalGroup(
            panelGraficoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 457, Short.MAX_VALUE)
        );
        panelGraficoLayout.setVerticalGroup(
            panelGraficoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 297, Short.MAX_VALUE)
        );

        jLabel13.setText("Tamaño (MB):");

        spnTamaño.setModel(new javax.swing.SpinnerNumberModel(100, null, null, 1));

        jLabel14.setText("Cola de Listos-Suspendidos");

        txtColaListosSuspendidos.setColumns(20);
        txtColaListosSuspendidos.setRows(5);
        jScrollPane5.setViewportView(txtColaListosSuspendidos);

        jLabel15.setText("Velocidad (ms):");

        spnVelocidad.setModel(new javax.swing.SpinnerNumberModel(500, null, null, 1));

        jLabel16.setText("Cola de Bloqueados-Suspendidos");

        txtColaBloqueadosSuspendidos.setColumns(20);
        txtColaBloqueadosSuspendidos.setRows(5);
        jScrollPane6.setViewportView(txtColaBloqueadosSuspendidos);

        lblMAR.setText("MAR: -");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 207, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(42, 42, 42)
                        .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(34, 34, 34)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 195, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(jScrollPane4)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(txtNombreProceso, javax.swing.GroupLayout.PREFERRED_SIZE, 120, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(156, 156, 156)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel6)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(lblCicloActual, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGap(208, 208, 208))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel4)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addComponent(lblProcesoCPU, javax.swing.GroupLayout.PREFERRED_SIZE, 205, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(18, 18, 18)
                                        .addComponent(lblProgramCounter, javax.swing.GroupLayout.PREFERRED_SIZE, 190, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addComponent(lblMAR, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(cmbAlgoritmo, javax.swing.GroupLayout.PREFERRED_SIZE, 124, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(btnIniciar)
                                        .addGap(51, 51, 51)
                                        .addComponent(jLabel15, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(spnVelocidad, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(0, 0, Short.MAX_VALUE))))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(chkIoBound)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel8, javax.swing.GroupLayout.PREFERRED_SIZE, 149, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spnInstrucciones, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                        .addComponent(jLabel12, javax.swing.GroupLayout.PREFERRED_SIZE, 59, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(spnPrioridad))
                                    .addComponent(jLabel10, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(btnCrearProceso, javax.swing.GroupLayout.Alignment.LEADING))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spnInstruccionIO, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel13, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spnTamaño, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(132, 132, 132)
                        .addComponent(panelGrafico, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
            .addGroup(layout.createSequentialGroup()
                .addGap(64, 64, 64)
                .addComponent(jLabel11, javax.swing.GroupLayout.PREFERRED_SIZE, 157, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(68, 68, 68)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(138, 138, 138)
                .addComponent(jLabel14)
                .addGap(81, 81, 81)
                .addComponent(jLabel16, javax.swing.GroupLayout.PREFERRED_SIZE, 188, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(89, 89, 89)
                .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 79, Short.MAX_VALUE)
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(39, 39, 39))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(92, 92, 92)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel1)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jLabel14)
                                .addComponent(jLabel16)
                                .addComponent(jLabel2))))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel3)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane6, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 58, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 58, Short.MAX_VALUE)
                            .addComponent(jScrollPane5, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel11)
                .addGap(12, 12, 12)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.DEFAULT_SIZE, 245, Short.MAX_VALUE)
                        .addGap(39, 39, 39)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel7)
                            .addComponent(txtNombreProceso, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(lblProcesoCPU))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel5)
                            .addComponent(lblProgramCounter))
                        .addGap(44, 44, 44)
                        .addComponent(lblMAR)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel6)
                            .addComponent(lblCicloActual))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel9)
                            .addComponent(cmbAlgoritmo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(20, 20, 20)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnIniciar)
                            .addComponent(jLabel15)
                            .addComponent(spnVelocidad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel8)
                            .addComponent(spnInstrucciones, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(chkIoBound)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel10)
                            .addComponent(spnInstruccionIO, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(7, 7, 7)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel12)
                            .addComponent(spnPrioridad, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel13)
                            .addComponent(spnTamaño, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(13, 13, 13)
                        .addComponent(btnCrearProceso))
                    .addComponent(panelGrafico, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void btnIniciarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnIniciarActionPerformed
        btnIniciar.setEnabled(false);
        Logger.iniciar();
        Thread hiloSimulacion = new Thread(this);
        hiloSimulacion.start();
    }//GEN-LAST:event_btnIniciarActionPerformed

    private void btnCrearProcesoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCrearProcesoActionPerformed
       String nombre = txtNombreProceso.getText();
    int instrucciones = (int) spnInstrucciones.getValue();
    boolean esIO = chkIoBound.isSelected();
    int instruccionIO = (int) spnInstruccionIO.getValue();
    int prioridad = (int) spnPrioridad.getValue();
    int tamaño = (int) spnTamaño.getValue(); // Leemos el nuevo campo

    if (nombre.isEmpty() || instrucciones <= 0 || tamaño <= 0) {
        JOptionPane.showMessageDialog(this, "Por favor, complete los campos válidamente.", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }

    Proceso nuevoProceso = new Proceso(nombre, instrucciones, esIO, instruccionIO, prioridad, tamaño);
    PCB nuevoPcb = new PCB(nuevoProceso);
    nuevoPcb.setTiempoDeLlegada(cicloGlobal);

    // --- LÓGICA DE GESTIÓN DE MEMORIA ---
    if ((memoriaEnUso + tamaño) <= MEMORIA_TOTAL_MB) {
        // Hay espacio en la memoria
        memoriaEnUso += tamaño;
        nuevoPcb.setEstado(PCB.EstadoProceso.LISTO);
        colaListos.encolar(nuevoPcb);
        System.out.println("Proceso " + nuevoPcb.getId() + " admitido en memoria.");
    } else {
        // No hay espacio, va a la cola de suspendidos
        nuevoPcb.setEstado(PCB.EstadoProceso.LISTO_SUSPENDIDO); // (Necesitaremos añadir este estado)
        colaListosSuspendidos.encolar(nuevoPcb);
        System.out.println("Proceso " + nuevoPcb.getId() + " enviado a suspendidos por falta de memoria.");
    }
    
    limpiarCamposCreacion();
    actualizarGUI();
    }//GEN-LAST:event_btnCrearProcesoActionPerformed

    /**
     * @param args the command line arguments
     */


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnCrearProceso;
    private javax.swing.JButton btnIniciar;
    private javax.swing.JCheckBox chkIoBound;
    private javax.swing.JComboBox<String> cmbAlgoritmo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JLabel lblCicloActual;
    private javax.swing.JLabel lblMAR;
    private javax.swing.JLabel lblProcesoCPU;
    private javax.swing.JLabel lblProgramCounter;
    private javax.swing.JPanel panelGrafico;
    private javax.swing.JSpinner spnInstruccionIO;
    private javax.swing.JSpinner spnInstrucciones;
    private javax.swing.JSpinner spnPrioridad;
    private javax.swing.JSpinner spnTamaño;
    private javax.swing.JSpinner spnVelocidad;
    private javax.swing.JTextArea txtColaBloqueados;
    private javax.swing.JTextArea txtColaBloqueadosSuspendidos;
    private javax.swing.JTextArea txtColaListos;
    private javax.swing.JTextArea txtColaListosSuspendidos;
    private javax.swing.JTextArea txtMetricas;
    private javax.swing.JTextField txtNombreProceso;
    private javax.swing.JTextArea txtTerminados;
    // End of variables declaration//GEN-END:variables

@Override
public void run() {
    while (procesoEnCpu != null || !colaListos.estaVacia() || !colaBloqueados.estaVacia() || !colaListosSuspendidos.estaVacia()) {

        gestionarColaBloqueados();
        gestionarColaSuspendidos();
        String algoritmo = (String) cmbAlgoritmo.getSelectedItem();

        // --- LÓGICA DE APROPIACIÓN ---
        if (procesoEnCpu != null && !colaListos.estaVacia()) {
            if (algoritmo.equals("Prioridad Apropiativo")) {
                PCB masPrioritario = planificador.verProcesoMasPrioritario(colaListos);
                if (masPrioritario.getProcesoInfo().getPrioridad() < procesoEnCpu.getProcesoInfo().getPrioridad()) {
                    Logger.log("Ciclo " + cicloGlobal + ": Proceso ID " + procesoEnCpu.getId() + " interrumpido por Proceso ID " + masPrioritario.getId() + " (Prioridad).");
                    procesoEnCpu.setEstado(PCB.EstadoProceso.LISTO);
                    colaListos.encolar(procesoEnCpu);
                    procesoEnCpu = null;
                }
            } else if (algoritmo.equals("SRT (Shortest Remaining Time)")) {
                PCB masCorto = planificador.verProcesoMasCortoRestante(colaListos);
                if (masCorto.getTiempoEjecucionRestante() < procesoEnCpu.getTiempoEjecucionRestante()) {
                    Logger.log("Ciclo " + cicloGlobal + ": Proceso ID " + procesoEnCpu.getId() + " interrumpido por Proceso ID " + masCorto.getId() + " (SRT).");
                    procesoEnCpu.setEstado(PCB.EstadoProceso.LISTO);
                    colaListos.encolar(procesoEnCpu);
                    procesoEnCpu = null;
                }
            }
        }
        
        if (procesoEnCpu == null) {
            procesoEnCpu = planificador.seleccionarProceso(colaListos, algoritmo);
            if (procesoEnCpu != null) {
                Logger.log("Ciclo " + cicloGlobal + ": Planificador selecciona Proceso ID " + procesoEnCpu.getId() + " (" + algoritmo + ").");
                procesoEnCpu.setEstado(PCB.EstadoProceso.EJECUCION);
                if (algoritmo.equals("Round Robin")) {
                    procesoEnCpu.setQuantumRestante(QUANTUM); 
                }
            }
        }

        cicloGlobal++;

        if (procesoEnCpu != null) {
            ciclosOcupado++; 
            procesoEnCpu.setTiempoEjecucionRestante(procesoEnCpu.getTiempoEjecucionRestante() - 1);

            if (algoritmo.equals("Round Robin")) {
                procesoEnCpu.setQuantumRestante(procesoEnCpu.getQuantumRestante() - 1);
            }
            
            if (procesoEnCpu.getProcesoInfo().esIoBound() && 
                procesoEnCpu.getProgramCounter() == procesoEnCpu.getProcesoInfo().getInstruccionBloqueo()) {
                
                Logger.log("Ciclo " + cicloGlobal + ": Proceso ID " + procesoEnCpu.getId() + " se bloquea por E/S.");
                procesoEnCpu.setEstado(PCB.EstadoProceso.BLOQUEADO);
                procesoEnCpu.setTiempoRestanteBloqueo(10);
                colaBloqueados.encolar(procesoEnCpu);
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
                procesoEnCpu = null;

            } else if (procesoEnCpu.getProgramCounter() >= procesoEnCpu.getProcesoInfo().getNumeroInstrucciones()) {
                Logger.log("Ciclo " + cicloGlobal + ": Proceso ID " + procesoEnCpu.getId() + " ha terminado.");
                procesoEnCpu.setEstado(PCB.EstadoProceso.TERMINADO);
                procesoEnCpu.setTiempoDeFinalizacion(cicloGlobal);
                memoriaEnUso -= procesoEnCpu.getProcesoInfo().getTamañoEnMemoria(); 
                colaTerminados.encolar(procesoEnCpu);
                procesoEnCpu = null;
                
            } else if (algoritmo.equals("Round Robin") && procesoEnCpu.getQuantumRestante() <= 0) {
                Logger.log("Ciclo " + cicloGlobal + ": Proceso ID " + procesoEnCpu.getId() + " fin de quantum (Round Robin).");
                procesoEnCpu.setEstado(PCB.EstadoProceso.LISTO);
                colaListos.encolar(procesoEnCpu);
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
                procesoEnCpu = null;

            } else {
                procesoEnCpu.setProgramCounter(procesoEnCpu.getProgramCounter() + 1);
            }
        }

        SwingUtilities.invokeLater(() -> {
            actualizarGUI();
            actualizarGrafico();
        });

        try { 
            int velocidad = (int) spnVelocidad.getValue();
            Thread.sleep(velocidad); 
        } catch (InterruptedException e) { 
            Thread.currentThread().interrupt(); 
        }
    }
    
    System.out.println("--- Simulación Finalizada ---");
    calcularYMostrarMetricas();
    Logger.cerrar();
    SwingUtilities.invokeLater(() -> {
        btnIniciar.setEnabled(true);
        cmbAlgoritmo.setEnabled(true);
    });
}// <--- FIN DEL MÉTODO run()




private void gestionarColaBloqueados() {
    // Procesa la cola de bloqueados en memoria
    if (!colaBloqueados.estaVacia()) {
        Nodo actual = colaBloqueados.getFrente();
        while (actual != null) {
            PCB pcb = actual.getPcb();
            pcb.setTiempoRestanteBloqueo(pcb.getTiempoRestanteBloqueo() - 1);
            actual = actual.getSiguiente();
        }
        
        while (!colaBloqueados.estaVacia() && colaBloqueados.verFrente().getTiempoRestanteBloqueo() <= 0) {
            PCB pcbListo = colaBloqueados.desencolar();
            pcbListo.setEstado(PCB.EstadoProceso.LISTO);
            colaListos.encolar(pcbListo);
            Logger.log("Ciclo " + cicloGlobal + ": Proceso ID " + pcbListo.getId() + " fin de bloqueo. Va a Listos.");
        }
    }
    
    // --- NUEVO: Procesa la cola de bloqueados-suspendidos ---
    if (!colaBloqueadosSuspendidos.estaVacia()) {
        Nodo actual = colaBloqueadosSuspendidos.getFrente();
        while (actual != null) {
            PCB pcb = actual.getPcb();
            pcb.setTiempoRestanteBloqueo(pcb.getTiempoRestanteBloqueo() - 1);
            actual = actual.getSiguiente();
        }
        
        while (!colaBloqueadosSuspendidos.estaVacia() && colaBloqueadosSuspendidos.verFrente().getTiempoRestanteBloqueo() <= 0) {
            PCB pcbListo = colaBloqueadosSuspendidos.desencolar();
            pcbListo.setEstado(PCB.EstadoProceso.LISTO_SUSPENDIDO);
            colaListosSuspendidos.encolar(pcbListo); // Va a Listos-Suspendido
            Logger.log("Ciclo " + cicloGlobal + ": Proceso ID " + pcbListo.getId() + " fin de bloqueo (suspendido). Va a Listos-Suspendido.");
        }
    }
}


private void calcularYMostrarMetricas() {
    if (colaTerminados.estaVacia()) return;

    StringBuilder reporte = new StringBuilder();
    reporte.append("--- REPORTE DE RENDIMIENTO ---\n");
    
    int totalRetorno = 0;
    int totalEspera = 0;
    int numProcesos = 0;

    Nodo actual = colaTerminados.getFrente();
    while(actual != null) {
        // ... (tu código existente para calcular retorno y espera) ...
        // Esto no cambia
        PCB pcb = actual.getPcb();
        int retorno = pcb.getTiempoDeFinalizacion() - pcb.getTiempoDeLlegada();
        pcb.setTiempoDeRetorno(retorno);
        int espera = retorno - pcb.getProcesoInfo().getNumeroInstrucciones();
        pcb.setTiempoDeEspera(espera);
        totalRetorno += retorno;
        totalEspera += espera;
        numProcesos++;
        reporte.append("ID: ").append(pcb.getId())
               .append(" | T. Retorno: ").append(retorno)
               .append(" | T. Espera: ").append(espera).append("\n");
        actual = actual.getSiguiente();
    }

    // --- INICIO DE LAS NUEVAS MÉTRICAS ---
    double promedioRetorno = (double) totalRetorno / numProcesos;
    double promedioEspera = (double) totalEspera / numProcesos;
    
    // Throughput: Procesos completados por unidad de tiempo
    double throughput = (double) numProcesos / cicloGlobal;
    
    // Utilización de CPU: Porcentaje de tiempo que la CPU estuvo ocupada
    double utilizacionCPU = ((double) ciclosOcupado / cicloGlobal) * 100.0;

    reporte.append("---------------------------------\n");
    reporte.append(String.format("Promedio de T. de Retorno: %.2f\n", promedioRetorno));
    reporte.append(String.format("Promedio de T. de Espera: %.2f\n", promedioEspera));
    reporte.append(String.format("Throughput: %.3f procesos/ciclo\n", throughput));
    reporte.append(String.format("Utilización de CPU: %.2f%%\n", utilizacionCPU));
    // --- FIN DE LAS NUEVAS MÉTRICAS ---

    txtMetricas.setText(reporte.toString());
    }

private void inicializarGrafico() {
    // 1. Crear el conjunto de datos
    this.seriesUtilizacionCPU = new XYSeries("Utilización de CPU");
    XYSeriesCollection dataset = new XYSeriesCollection(this.seriesUtilizacionCPU);

    // 2. Crear el gráfico
    this.grafico = ChartFactory.createXYLineChart(
        "Rendimiento del Sistema", // Título del gráfico
        "Ciclo",                   // Etiqueta del eje X
        "Utilización de CPU (%)",  // Etiqueta del eje Y
        dataset                    // Los datos
    );

    // 3. Crear el panel del gráfico y añadirlo a nuestro JPanel
    ChartPanel chartPanel = new ChartPanel(grafico);
    panelGrafico.setLayout(new java.awt.BorderLayout());
    panelGrafico.add(chartPanel, BorderLayout.CENTER);
    panelGrafico.validate();
    }

private void actualizarGrafico() {
    if (cicloGlobal > 0) {
        // Calculamos la utilización de CPU actual
        double utilizacionActual = ((double) ciclosOcupado / cicloGlobal) * 100.0;
        
        // Añadimos el nuevo punto de datos (ciclo, utilización) a la serie
        this.seriesUtilizacionCPU.add(cicloGlobal, utilizacionActual);
    }
   }

private void limpiarCamposCreacion() {
    // Resetea los campos del formulario a sus valores por defecto
    txtNombreProceso.setText("");
    spnInstrucciones.setValue(0);
    chkIoBound.setSelected(false);
    spnInstruccionIO.setValue(0);
    spnPrioridad.setValue(10);
    spnTamaño.setValue(100);
    
    }

private void gestionarColaSuspendidos() {
    if (!colaListosSuspendidos.estaVacia()) {
        PCB procesoInteresado = colaListosSuspendidos.verFrente();
        
        if ((memoriaEnUso + procesoInteresado.getProcesoInfo().getTamañoEnMemoria()) <= MEMORIA_TOTAL_MB) {
            // Caso 1: Hay espacio, se admite el proceso
            PCB procesoAdmitido = colaListosSuspendidos.desencolar();
            procesoAdmitido.setEstado(PCB.EstadoProceso.LISTO);
            memoriaEnUso += procesoAdmitido.getProcesoInfo().getTamañoEnMemoria();
            colaListos.encolar(procesoAdmitido);
            Logger.log("Ciclo " + cicloGlobal + ": Proceso ID " + procesoAdmitido.getId() + " admitido a memoria. Uso: " + memoriaEnUso + "MB.");
        
        } else {
            // Caso 2: No hay espacio. ¿Podemos hacer espacio?
            // Esto solo tiene sentido si no hay nada en la cola de listos y la CPU está ociosa.
            if (colaListos.estaVacia() && procesoEnCpu == null && !colaBloqueados.estaVacia()) {
                
                // Sacamos a un proceso bloqueado para liberar su memoria
                PCB procesoASuspender = colaBloqueados.desencolar();
                memoriaEnUso -= procesoASuspender.getProcesoInfo().getTamañoEnMemoria();
                
                procesoASuspender.setEstado(PCB.EstadoProceso.BLOQUEADO_SUSPENDIDO);
                colaBloqueadosSuspendidos.encolar(procesoASuspender);
                Logger.log("Ciclo " + cicloGlobal + ": Swapping. Proceso ID " + procesoASuspender.getId() + " movido a Bloqueado-Suspendido para liberar memoria.");
            }
        }
    }
}

private void guardarConfiguracion() {
    // Creamos un objeto JSON
    JSONObject config = new JSONObject();

    // Ponemos el valor actual del spinner en el objeto JSON
    config.put("velocidadSimulacion", (int) spnVelocidad.getValue());

    // Usamos un try-with-resources para escribir el archivo y asegurarnos de que se cierre
    try (FileWriter file = new FileWriter("config.json")) {
        file.write(config.toString(4)); // El '4' es para que se guarde con formato legible
        System.out.println("Configuración guardada en config.json");
    } catch (IOException e) {
        e.printStackTrace();
    }
}

private void cargarConfiguracion() {
    try {
        // Leemos el contenido del archivo a un string
        String contenido = new String(Files.readAllBytes(Paths.get("config.json")));

        // Convertimos el string a un objeto JSON
        JSONObject config = new JSONObject(contenido);

        // Obtenemos el valor guardado y lo ponemos en el spinner
        int velocidadGuardada = config.getInt("velocidadSimulacion");
        spnVelocidad.setValue(velocidadGuardada);
        System.out.println("Configuración cargada desde config.json");

    } catch (IOException e) {
        // Si el archivo no existe, no es un error. Simplemente usamos los valores por defecto.
        System.out.println("No se encontró config.json. Usando valores por defecto.");
    }
}
}
